<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘æ’­æ”¾æµç•…æ€§æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background: #e9ecef;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .playing {
            background: #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>éŸ³é¢‘æ’­æ”¾æµç•…æ€§æµ‹è¯•</h1>
        <p>æµ‹è¯•ä¼˜åŒ–åçš„éŸ³é¢‘æ’­æ”¾åŠŸèƒ½ï¼Œæ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¡é¡¿é—®é¢˜</p>
        
        <button id="testSingleBtn">æµ‹è¯•å•ä¸ªéŸ³é¢‘æ’­æ”¾</button>
        <button id="testMultipleBtn">æµ‹è¯•è¿ç»­éŸ³é¢‘æ’­æ”¾</button>
        <button id="testOverlapBtn">æµ‹è¯•é‡å éŸ³é¢‘æ’­æ”¾</button>
        <button id="stopBtn" disabled>åœæ­¢æ‰€æœ‰æ’­æ”¾</button>
        
        <div class="status" id="status">å‡†å¤‡æµ‹è¯•</div>
        
        <div>
            <h3>æµ‹è¯•æ—¥å¿—</h3>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        // å…¨å±€AudioContextç”¨äºéŸ³é¢‘æ’­æ”¾ï¼Œé¿å…é‡å¤åˆ›å»ºå¯¼è‡´çš„å¡é¡¿
        let globalAudioContext = null;
        // éŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—ç®¡ç†
        let audioPlaybackQueue = Promise.resolve();
        let currentAudioSource = null;

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('log');
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(message);
        }

        function setStatus(message, isPlaying = false) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = isPlaying ? 'status playing' : 'status';
        }

        // ç”Ÿæˆæµ‹è¯•éŸ³é¢‘æ•°æ®ï¼ˆPCM16æ ¼å¼ï¼‰
        function generateTestAudio(frequency, duration) {
            const sampleRate = 24000;
            const sampleCount = sampleRate * duration;
            
            // ç”ŸæˆPCM16æ•°æ®
            const pcm16Data = new Int16Array(sampleCount);
            for (let i = 0; i < sampleCount; i++) {
                const sample = Math.sin(2 * Math.PI * frequency * i / sampleRate) * 0.5; // é™ä½éŸ³é‡
                pcm16Data[i] = Math.round(sample * 16383);
            }
            
            // è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„
            const bytes = new Uint8Array(pcm16Data.length * 2);
            for (let i = 0; i < pcm16Data.length; i++) {
                const value = pcm16Data[i];
                bytes[i * 2] = value & 0xFF;
                bytes[i * 2 + 1] = (value >> 8) & 0xFF;
            }
            
            // ç¼–ç ä¸ºBase64
            const blob = new Blob([bytes]);
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function() {
                    const result = reader.result;
                    if (typeof result === 'string') {
                        const base64Audio = result.split(',')[1];
                        resolve(base64Audio);
                    }
                };
                reader.readAsDataURL(blob);
            });
        }

        // ä¼˜åŒ–åçš„éŸ³é¢‘æ’­æ”¾å‡½æ•°
        async function handleAudioPlayback(audioData) {
            // å°†éŸ³é¢‘æ’­æ”¾åŠ å…¥é˜Ÿåˆ—ï¼Œé¿å…é‡å æ’­æ”¾
            audioPlaybackQueue = audioPlaybackQueue.then(async () => {
                try {
                    // åœæ­¢å½“å‰æ’­æ”¾çš„éŸ³é¢‘ï¼ˆå¦‚æœæœ‰ï¼‰
                    if (currentAudioSource) {
                        currentAudioSource.stop();
                        currentAudioSource = null;
                    }
                    
                    // Decode base64 audio data
                    const binaryData = atob(audioData);
                    const arrayBuffer = new ArrayBuffer(binaryData.length);
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    for (let i = 0; i < binaryData.length; i++) {
                        uint8Array[i] = binaryData.charCodeAt(i);
                    }

                    // ä½¿ç”¨å…¨å±€AudioContexté¿å…é‡å¤åˆ›å»º
                    if (!globalAudioContext) {
                        globalAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: 24000 // GPT uses 24kHz
                        });
                    }
                    
                    // ç¡®ä¿AudioContextå¤„äºè¿è¡ŒçŠ¶æ€
                    if (globalAudioContext.state === 'suspended') {
                        await globalAudioContext.resume();
                    }
                    
                    // Convert PCM16 bytes to Float32 samples
                    const pcm16Data = new Int16Array(arrayBuffer);
                    const sampleCount = pcm16Data.length;
                    
                    if (sampleCount === 0) {
                        log('âš ï¸ ç©ºéŸ³é¢‘æ•°æ®ï¼Œè·³è¿‡æ’­æ”¾');
                        return;
                    }
                    
                    const audioBuffer = globalAudioContext.createBuffer(1, sampleCount, 24000); // mono, 24kHz
                    const channelData = audioBuffer.getChannelData(0);
                    
                    // Convert PCM16 to Float32 (-1 to 1 range) with better precision
                    for (let i = 0; i < sampleCount; i++) {
                        channelData[i] = Math.max(-1, Math.min(1, pcm16Data[i] / 32768.0));
                    }
                    
                    // åˆ›å»ºéŸ³é¢‘æºå¹¶æ’­æ”¾
                    const source = globalAudioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    currentAudioSource = source;
                    
                    // æ·»åŠ éŸ³é‡æ§åˆ¶å’Œä½é€šæ»¤æ³¢å™¨å‡å°‘å™ªéŸ³
                    const gainNode = globalAudioContext.createGain();
                    const filterNode = globalAudioContext.createBiquadFilter();
                    
                    gainNode.gain.value = 0.7; // é€‚ä¸­çš„éŸ³é‡
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 8000; // 8kHzä½é€šæ»¤æ³¢ï¼Œå»é™¤é«˜é¢‘å™ªéŸ³
                    filterNode.Q.value = 1;
                    
                    source.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(globalAudioContext.destination);
                    
                    // è¿”å›Promiseä»¥ä¾¿ç­‰å¾…æ’­æ”¾å®Œæˆ
                    return new Promise((resolve, reject) => {
                        source.onended = () => {
                            log(`âœ“ éŸ³é¢‘æ’­æ”¾å®Œæˆ: ${audioBuffer.duration.toFixed(2)}s`);
                            currentAudioSource = null;
                            setStatus('æ’­æ”¾å®Œæˆ');
                            resolve();
                        };
                        
                        try {
                            source.start();
                            log(`ğŸ”Š å¼€å§‹æ’­æ”¾éŸ³é¢‘: ${sampleCount} æ ·æœ¬, ${audioBuffer.duration.toFixed(2)}s`);
                            setStatus(`æ­£åœ¨æ’­æ”¾ ${audioBuffer.duration.toFixed(2)}s éŸ³é¢‘...`, true);
                            
                            // è®¾ç½®è¶…æ—¶ä»¥é˜²éŸ³é¢‘å¡ä½
                            setTimeout(() => {
                                if (currentAudioSource === source) {
                                    log('âš ï¸ éŸ³é¢‘æ’­æ”¾è¶…æ—¶ï¼Œåœæ­¢æ’­æ”¾');
                                    try {
                                        source.stop();
                                    } catch (e) {
                                        log(`è­¦å‘Š: åœæ­¢è¶…æ—¶éŸ³é¢‘æºæ—¶å‡ºé”™: ${e.message}`);
                                    }
                                    currentAudioSource = null;
                                    setStatus('æ’­æ”¾è¶…æ—¶');
                                    resolve();
                                }
                            }, audioBuffer.duration * 1000 + 1000); // éŸ³é¢‘æ—¶é•¿ + 1ç§’ç¼“å†²
                            
                        } catch (error) {
                            log(`âŒ å¯åŠ¨éŸ³é¢‘æºå¤±è´¥: ${error.message}`);
                            currentAudioSource = null;
                            setStatus('æ’­æ”¾å¤±è´¥');
                            reject(error);
                        }
                    });
                    
                } catch (error) {
                    log(`âŒ éŸ³é¢‘æ’­æ”¾å¤±è´¥: ${error.message}`);
                    setStatus('æ’­æ”¾å¤±è´¥');
                    throw error;
                }
            });
            
            return audioPlaybackQueue;
        }

        // åœæ­¢æ‰€æœ‰éŸ³é¢‘æ’­æ”¾
        function stopAllAudio() {
            if (currentAudioSource) {
                try {
                    currentAudioSource.stop();
                    log('ğŸ›‘ åœæ­¢å½“å‰éŸ³é¢‘æ’­æ”¾');
                } catch (error) {
                    log(`è­¦å‘Š: åœæ­¢éŸ³é¢‘æºæ—¶å‡ºé”™: ${error.message}`);
                }
                currentAudioSource = null;
            }
            
            if (globalAudioContext && globalAudioContext.state !== 'closed') {
                try {
                    globalAudioContext.close();
                    log('ğŸ›‘ å…³é—­AudioContext');
                } catch (error) {
                    log(`è­¦å‘Š: å…³é—­AudioContextæ—¶å‡ºé”™: ${error.message}`);
                }
                globalAudioContext = null;
            }
            
            // é‡ç½®æ’­æ”¾é˜Ÿåˆ—
            audioPlaybackQueue = Promise.resolve();
            setStatus('å·²åœæ­¢æ‰€æœ‰æ’­æ”¾');
        }

        // æµ‹è¯•å•ä¸ªéŸ³é¢‘æ’­æ”¾
        async function testSingleAudio() {
            try {
                log('ğŸµ å¼€å§‹æµ‹è¯•å•ä¸ªéŸ³é¢‘æ’­æ”¾...');
                setStatus('ç”Ÿæˆæµ‹è¯•éŸ³é¢‘...');
                
                const audioData = await generateTestAudio(440, 2); // 440Hz, 2ç§’
                log(`ç”Ÿæˆæµ‹è¯•éŸ³é¢‘: ${audioData.length} å­—ç¬¦`);
                
                await handleAudioPlayback(audioData);
                log('âœ… å•ä¸ªéŸ³é¢‘æ’­æ”¾æµ‹è¯•å®Œæˆ');
                
            } catch (error) {
                log(`âŒ å•ä¸ªéŸ³é¢‘æ’­æ”¾æµ‹è¯•å¤±è´¥: ${error.message}`);
                setStatus('æµ‹è¯•å¤±è´¥');
            }
        }

        // æµ‹è¯•è¿ç»­éŸ³é¢‘æ’­æ”¾
        async function testMultipleAudio() {
            try {
                log('ğŸµ å¼€å§‹æµ‹è¯•è¿ç»­éŸ³é¢‘æ’­æ”¾...');
                setStatus('ç”Ÿæˆå¤šä¸ªæµ‹è¯•éŸ³é¢‘...');
                
                const frequencies = [440, 523, 659, 784]; // Cå¤§è°ƒå’Œå¼¦
                const promises = [];
                
                for (let i = 0; i < frequencies.length; i++) {
                    const freq = frequencies[i];
                    log(`æ’­æ”¾éŸ³é¢‘ ${i + 1}/${frequencies.length}: ${freq}Hz`);
                    
                    const audioData = await generateTestAudio(freq, 1); // 1ç§’æ¯ä¸ªéŸ³ç¬¦
                    promises.push(handleAudioPlayback(audioData));
                    
                    // ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†æ’­æ”¾ä¸‹ä¸€ä¸ªï¼ˆæµ‹è¯•é˜Ÿåˆ—åŠŸèƒ½ï¼‰
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                await Promise.all(promises);
                log('âœ… è¿ç»­éŸ³é¢‘æ’­æ”¾æµ‹è¯•å®Œæˆ');
                
            } catch (error) {
                log(`âŒ è¿ç»­éŸ³é¢‘æ’­æ”¾æµ‹è¯•å¤±è´¥: ${error.message}`);
                setStatus('æµ‹è¯•å¤±è´¥');
            }
        }

        // æµ‹è¯•é‡å éŸ³é¢‘æ’­æ”¾ï¼ˆåº”è¯¥è¢«é˜Ÿåˆ—ç®¡ç†ï¼‰
        async function testOverlapAudio() {
            try {
                log('ğŸµ å¼€å§‹æµ‹è¯•é‡å éŸ³é¢‘æ’­æ”¾...');
                setStatus('åŒæ—¶è§¦å‘å¤šä¸ªéŸ³é¢‘æ’­æ”¾...');
                
                // åŒæ—¶è§¦å‘å¤šä¸ªéŸ³é¢‘æ’­æ”¾ï¼Œæµ‹è¯•é˜Ÿåˆ—ç®¡ç†
                const promises = [];
                const frequencies = [330, 440, 550];
                
                for (const freq of frequencies) {
                    const audioData = await generateTestAudio(freq, 1.5);
                    promises.push(handleAudioPlayback(audioData));
                    log(`è§¦å‘ ${freq}Hz éŸ³é¢‘æ’­æ”¾`);
                }
                
                // ç­‰å¾…æ‰€æœ‰æ’­æ”¾å®Œæˆ
                await Promise.all(promises);
                log('âœ… é‡å éŸ³é¢‘æ’­æ”¾æµ‹è¯•å®Œæˆï¼ˆåº”è¯¥æ˜¯é¡ºåºæ’­æ”¾ï¼‰');
                
            } catch (error) {
                log(`âŒ é‡å éŸ³é¢‘æ’­æ”¾æµ‹è¯•å¤±è´¥: ${error.message}`);
                setStatus('æµ‹è¯•å¤±è´¥');
            }
        }

        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('testSingleBtn').addEventListener('click', testSingleAudio);
        document.getElementById('testMultipleBtn').addEventListener('click', testMultipleAudio);
        document.getElementById('testOverlapBtn').addEventListener('click', testOverlapAudio);
        document.getElementById('stopBtn').addEventListener('click', () => {
            stopAllAudio();
            document.getElementById('stopBtn').disabled = true;
        });

        // å¯ç”¨åœæ­¢æŒ‰é’®
        document.addEventListener('click', (e) => {
            if (e.target.id.includes('test')) {
                document.getElementById('stopBtn').disabled = false;
            }
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', stopAllAudio);

        log('ğŸ“± éŸ³é¢‘æ’­æ”¾æµç•…æ€§æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ');
        log('ğŸ’¡ æç¤ºï¼šç‚¹å‡»æµ‹è¯•æŒ‰é’®éªŒè¯éŸ³é¢‘æ’­æ”¾æ˜¯å¦æµç•…ï¼Œæ— å¡é¡¿');
    </script>
</body>
</html>