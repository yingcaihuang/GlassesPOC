<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘çˆ†ç ´éŸ³ä¿®å¤æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background: #e9ecef;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .comparison {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .comparison > div {
            flex: 1;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .old-method {
            background: #fff3cd;
            border-color: #ffeaa7;
        }
        .new-method {
            background: #d4edda;
            border-color: #c3e6cb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>éŸ³é¢‘çˆ†ç ´éŸ³ä¿®å¤æµ‹è¯•</h1>
        <p>æµ‹è¯•ä¿®å¤åçš„éŸ³é¢‘æ’­æ”¾ï¼Œæ£€æŸ¥æ˜¯å¦è¿˜æœ‰çˆ†ç ´éŸ³é—®é¢˜</p>
        
        <div class="comparison">
            <div class="old-method">
                <h3>æ—§æ–¹æ³•ï¼ˆå¯èƒ½æœ‰çˆ†ç ´éŸ³ï¼‰</h3>
                <button onclick="testOldMethod()">æµ‹è¯•æ—§æ–¹æ³•æ’­æ”¾</button>
                <p>ç›´æ¥æ’­æ”¾éŸ³é¢‘ï¼Œæ²¡æœ‰æ·¡å…¥æ·¡å‡ºæ•ˆæœ</p>
            </div>
            <div class="new-method">
                <h3>æ–°æ–¹æ³•ï¼ˆä¿®å¤çˆ†ç ´éŸ³ï¼‰</h3>
                <button onclick="testNewMethod()">æµ‹è¯•æ–°æ–¹æ³•æ’­æ”¾</button>
                <p>æ·»åŠ æ·¡å…¥æ·¡å‡ºå’Œé™éŸ³å¡«å……</p>
            </div>
        </div>
        
        <button onclick="testShortAudio()">æµ‹è¯•çŸ­éŸ³é¢‘ï¼ˆå®¹æ˜“å‡ºç°çˆ†ç ´éŸ³ï¼‰</button>
        <button onclick="testSequentialAudio()">æµ‹è¯•è¿ç»­æ’­æ”¾ï¼ˆæ£€æŸ¥åˆ‡æ¢æ—¶çš„çˆ†ç ´éŸ³ï¼‰</button>
        
        <div class="status" id="status">å‡†å¤‡æµ‹è¯•</div>
        
        <div>
            <h3>æµ‹è¯•æ—¥å¿—</h3>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        let globalAudioContext = null;
        let audioPlaybackQueue = Promise.resolve();
        let currentAudioSource = null;

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('log');
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(message);
        }

        function setStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // ç”Ÿæˆæµ‹è¯•éŸ³é¢‘æ•°æ®
        function generateTestAudio(frequency, duration, amplitude = 0.5) {
            const sampleRate = 24000;
            const sampleCount = sampleRate * duration;
            
            const pcm16Data = new Int16Array(sampleCount);
            for (let i = 0; i < sampleCount; i++) {
                const sample = Math.sin(2 * Math.PI * frequency * i / sampleRate) * amplitude;
                pcm16Data[i] = Math.round(sample * 16383);
            }
            
            const bytes = new Uint8Array(pcm16Data.length * 2);
            for (let i = 0; i < pcm16Data.length; i++) {
                const value = pcm16Data[i];
                bytes[i * 2] = value & 0xFF;
                bytes[i * 2 + 1] = (value >> 8) & 0xFF;
            }
            
            const blob = new Blob([bytes]);
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function() {
                    const result = reader.result;
                    if (typeof result === 'string') {
                        const base64Audio = result.split(',')[1];
                        resolve(base64Audio);
                    }
                };
                reader.readAsDataURL(blob);
            });
        }

        // æ—§æ–¹æ³•ï¼šç›´æ¥æ’­æ”¾ï¼Œå¯èƒ½æœ‰çˆ†ç ´éŸ³
        async function playAudioOldMethod(audioData) {
            try {
                const binaryData = atob(audioData);
                const arrayBuffer = new ArrayBuffer(binaryData.length);
                const uint8Array = new Uint8Array(arrayBuffer);
                
                for (let i = 0; i < binaryData.length; i++) {
                    uint8Array[i] = binaryData.charCodeAt(i);
                }

                if (!globalAudioContext) {
                    globalAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 24000
                    });
                }
                
                if (globalAudioContext.state === 'suspended') {
                    await globalAudioContext.resume();
                }
                
                const pcm16Data = new Int16Array(arrayBuffer);
                const sampleCount = pcm16Data.length;
                const audioBuffer = globalAudioContext.createBuffer(1, sampleCount, 24000);
                const channelData = audioBuffer.getChannelData(0);
                
                // ç›´æ¥è½¬æ¢ï¼Œæ²¡æœ‰ä»»ä½•å¤„ç†
                for (let i = 0; i < sampleCount; i++) {
                    channelData[i] = pcm16Data[i] / 32768.0;
                }
                
                const source = globalAudioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(globalAudioContext.destination); // ç›´æ¥è¿æ¥ï¼Œæ²¡æœ‰å¢ç›Šæ§åˆ¶
                
                return new Promise((resolve) => {
                    source.onended = () => {
                        log(`âœ“ æ—§æ–¹æ³•æ’­æ”¾å®Œæˆ: ${audioBuffer.duration.toFixed(2)}s`);
                        resolve();
                    };
                    
                    source.start();
                    log(`ğŸ”Š æ—§æ–¹æ³•æ’­æ”¾: ${sampleCount} æ ·æœ¬, ${audioBuffer.duration.toFixed(2)}s`);
                });
                
            } catch (error) {
                log(`âŒ æ—§æ–¹æ³•æ’­æ”¾å¤±è´¥: ${error.message}`);
                throw error;
            }
        }

        // æ–°æ–¹æ³•ï¼šå¸¦æ·¡å…¥æ·¡å‡ºå’Œé™éŸ³å¡«å……
        async function playAudioNewMethod(audioData) {
            try {
                const binaryData = atob(audioData);
                const arrayBuffer = new ArrayBuffer(binaryData.length);
                const uint8Array = new Uint8Array(arrayBuffer);
                
                for (let i = 0; i < binaryData.length; i++) {
                    uint8Array[i] = binaryData.charCodeAt(i);
                }

                if (!globalAudioContext) {
                    globalAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 24000
                    });
                }
                
                if (globalAudioContext.state === 'suspended') {
                    await globalAudioContext.resume();
                }
                
                const pcm16Data = new Int16Array(arrayBuffer);
                const originalSampleCount = pcm16Data.length;
                
                // æ·»åŠ é™éŸ³å¡«å……
                const paddingSamples = 240; // 10ms at 24kHz
                const totalSampleCount = originalSampleCount + (paddingSamples * 2);
                const audioBuffer = globalAudioContext.createBuffer(1, totalSampleCount, 24000);
                const channelData = audioBuffer.getChannelData(0);
                
                // å¼€å¤´é™éŸ³å¡«å……
                for (let i = 0; i < paddingSamples; i++) {
                    channelData[i] = 0;
                }
                
                // è½¬æ¢éŸ³é¢‘æ•°æ®
                for (let i = 0; i < originalSampleCount; i++) {
                    channelData[i + paddingSamples] = Math.max(-1, Math.min(1, pcm16Data[i] / 32768.0));
                }
                
                // ç»“å°¾é™éŸ³å¡«å……
                for (let i = originalSampleCount + paddingSamples; i < totalSampleCount; i++) {
                    channelData[i] = 0;
                }
                
                const source = globalAudioContext.createBufferSource();
                source.buffer = audioBuffer;
                
                // æ·»åŠ å¢ç›Šæ§åˆ¶å’Œæ»¤æ³¢å™¨
                const gainNode = globalAudioContext.createGain();
                const filterNode = globalAudioContext.createBiquadFilter();
                
                gainNode.gain.value = 0.7;
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 8000;
                filterNode.Q.value = 1;
                
                // æ·»åŠ æ·¡å…¥æ·¡å‡ºæ•ˆæœ
                const fadeTime = 0.01; // 10ms
                const currentTime = globalAudioContext.currentTime;
                
                gainNode.gain.setValueAtTime(0, currentTime);
                gainNode.gain.linearRampToValueAtTime(0.7, currentTime + fadeTime);
                
                const audioEndTime = currentTime + audioBuffer.duration;
                gainNode.gain.setValueAtTime(0.7, audioEndTime - fadeTime);
                gainNode.gain.linearRampToValueAtTime(0, audioEndTime);
                
                source.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(globalAudioContext.destination);
                
                return new Promise((resolve) => {
                    source.onended = () => {
                        log(`âœ“ æ–°æ–¹æ³•æ’­æ”¾å®Œæˆ: ${audioBuffer.duration.toFixed(2)}s`);
                        resolve();
                    };
                    
                    source.start();
                    log(`ğŸ”Š æ–°æ–¹æ³•æ’­æ”¾: ${originalSampleCount} æ ·æœ¬ (${totalSampleCount} å«å¡«å……), ${audioBuffer.duration.toFixed(2)}s`);
                });
                
            } catch (error) {
                log(`âŒ æ–°æ–¹æ³•æ’­æ”¾å¤±è´¥: ${error.message}`);
                throw error;
            }
        }

        // æµ‹è¯•æ—§æ–¹æ³•
        async function testOldMethod() {
            try {
                log('ğŸµ æµ‹è¯•æ—§æ–¹æ³•æ’­æ”¾ï¼ˆå¯èƒ½æœ‰çˆ†ç ´éŸ³ï¼‰...');
                setStatus('ç”Ÿæˆæµ‹è¯•éŸ³é¢‘...');
                
                const audioData = await generateTestAudio(440, 1, 0.8); // è¾ƒé«˜éŸ³é‡å®¹æ˜“å‡ºç°çˆ†ç ´éŸ³
                await playAudioOldMethod(audioData);
                
                setStatus('æ—§æ–¹æ³•æµ‹è¯•å®Œæˆ');
                log('âœ… æ—§æ–¹æ³•æµ‹è¯•å®Œæˆ - æ³¨æ„æ˜¯å¦æœ‰çˆ†ç ´éŸ³');
                
            } catch (error) {
                log(`âŒ æ—§æ–¹æ³•æµ‹è¯•å¤±è´¥: ${error.message}`);
                setStatus('æµ‹è¯•å¤±è´¥');
            }
        }

        // æµ‹è¯•æ–°æ–¹æ³•
        async function testNewMethod() {
            try {
                log('ğŸµ æµ‹è¯•æ–°æ–¹æ³•æ’­æ”¾ï¼ˆä¿®å¤çˆ†ç ´éŸ³ï¼‰...');
                setStatus('ç”Ÿæˆæµ‹è¯•éŸ³é¢‘...');
                
                const audioData = await generateTestAudio(440, 1, 0.8); // åŒæ ·çš„éŸ³é¢‘
                await playAudioNewMethod(audioData);
                
                setStatus('æ–°æ–¹æ³•æµ‹è¯•å®Œæˆ');
                log('âœ… æ–°æ–¹æ³•æµ‹è¯•å®Œæˆ - åº”è¯¥æ²¡æœ‰çˆ†ç ´éŸ³');
                
            } catch (error) {
                log(`âŒ æ–°æ–¹æ³•æµ‹è¯•å¤±è´¥: ${error.message}`);
                setStatus('æµ‹è¯•å¤±è´¥');
            }
        }

        // æµ‹è¯•çŸ­éŸ³é¢‘ï¼ˆæ›´å®¹æ˜“å‡ºç°çˆ†ç ´éŸ³ï¼‰
        async function testShortAudio() {
            try {
                log('ğŸµ æµ‹è¯•çŸ­éŸ³é¢‘æ’­æ”¾...');
                setStatus('æµ‹è¯•çŸ­éŸ³é¢‘...');
                
                // ç”Ÿæˆå¾ˆçŸ­çš„éŸ³é¢‘ï¼ˆ0.1ç§’ï¼‰
                const audioData = await generateTestAudio(880, 0.1, 0.9);
                
                log('æ’­æ”¾çŸ­éŸ³é¢‘ - æ—§æ–¹æ³•:');
                await playAudioOldMethod(audioData);
                
                await new Promise(resolve => setTimeout(resolve, 500)); // ç­‰å¾…500ms
                
                log('æ’­æ”¾çŸ­éŸ³é¢‘ - æ–°æ–¹æ³•:');
                await playAudioNewMethod(audioData);
                
                setStatus('çŸ­éŸ³é¢‘æµ‹è¯•å®Œæˆ');
                log('âœ… çŸ­éŸ³é¢‘æµ‹è¯•å®Œæˆ - å¯¹æ¯”ä¸¤ç§æ–¹æ³•çš„æ•ˆæœ');
                
            } catch (error) {
                log(`âŒ çŸ­éŸ³é¢‘æµ‹è¯•å¤±è´¥: ${error.message}`);
                setStatus('æµ‹è¯•å¤±è´¥');
            }
        }

        // æµ‹è¯•è¿ç»­æ’­æ”¾
        async function testSequentialAudio() {
            try {
                log('ğŸµ æµ‹è¯•è¿ç»­æ’­æ”¾ï¼ˆæ£€æŸ¥åˆ‡æ¢æ—¶çš„çˆ†ç ´éŸ³ï¼‰...');
                setStatus('æµ‹è¯•è¿ç»­æ’­æ”¾...');
                
                const frequencies = [330, 440, 550, 660];
                
                for (let i = 0; i < frequencies.length; i++) {
                    const freq = frequencies[i];
                    const audioData = await generateTestAudio(freq, 0.5, 0.7);
                    
                    log(`æ’­æ”¾éŸ³é¢‘ ${i + 1}/${frequencies.length}: ${freq}Hz`);
                    await playAudioNewMethod(audioData);
                    
                    // çŸ­æš‚é—´éš”
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                setStatus('è¿ç»­æ’­æ”¾æµ‹è¯•å®Œæˆ');
                log('âœ… è¿ç»­æ’­æ”¾æµ‹è¯•å®Œæˆ - æ£€æŸ¥éŸ³é¢‘åˆ‡æ¢æ—¶æ˜¯å¦æœ‰çˆ†ç ´éŸ³');
                
            } catch (error) {
                log(`âŒ è¿ç»­æ’­æ”¾æµ‹è¯•å¤±è´¥: ${error.message}`);
                setStatus('æµ‹è¯•å¤±è´¥');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆ
        log('ğŸ“± éŸ³é¢‘çˆ†ç ´éŸ³ä¿®å¤æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ');
        log('ğŸ’¡ æç¤ºï¼šå¯¹æ¯”æ—§æ–¹æ³•å’Œæ–°æ–¹æ³•ï¼Œæ£€æŸ¥æ˜¯å¦è¿˜æœ‰çˆ†ç ´éŸ³é—®é¢˜');
        log('ğŸ§ å»ºè®®ï¼šä½¿ç”¨è€³æœºæµ‹è¯•ä»¥æ›´å¥½åœ°å¬åˆ°å·®å¼‚');
    </script>
</body>
</html>