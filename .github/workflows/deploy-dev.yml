name: Deploy to Development

on:
  push:
    branches:
      - develop
      - feature/*
      - gpt-realtime-webrtc
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: smart-glasses-dev-rg
  VM_NAME: smart-glasses-dev-vm
  LOCATION: eastus
  CONTAINER_REGISTRY: smartglassesdevacr
  IMAGE_NAME: smart-glasses-app
  IMAGE_TAG: dev-${{ github.sha }}

permissions:
  id-token: write
  contents: read

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login with OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Create or Update Resource Group
      run: |
        az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location ${{ env.LOCATION }}

    - name: Create Azure Container Registry (if not exists)
      run: |
        if ! az acr show --name ${{ env.CONTAINER_REGISTRY }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "Creating Azure Container Registry for development..."
          az acr create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.CONTAINER_REGISTRY }} \
            --sku Basic \
            --admin-enabled true
        else
          echo "Development Azure Container Registry already exists"
        fi

    - name: Build and Push Docker Images to ACR
      run: |
        # Login to ACR
        az acr login --name ${{ env.CONTAINER_REGISTRY }}
        
        # Build and push backend image
        docker build -t ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-backend:${{ env.IMAGE_TAG }} .
        docker push ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-backend:${{ env.IMAGE_TAG }}
        
        # Build and push frontend image
        docker build -t ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-frontend:${{ env.IMAGE_TAG }} ./frontend
        docker push ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-frontend:${{ env.IMAGE_TAG }}

    - name: Create or Update Development VM
      run: |
        # Check if VM exists
        if ! az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "Creating Development Virtual Machine..."
          
          # Create VM with Docker extension
          az vm create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --image Ubuntu2204 \
            --size Standard_B1s \
            --admin-username azureuser \
            --generate-ssh-keys \
            --public-ip-sku Standard \
            --nsg-rule SSH
          
          # Open required ports
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 80 --priority 1001
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 443 --priority 1002
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 3000 --priority 1003
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 8080 --priority 1004
          
          # Install Docker on VM
          az vm extension set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vm-name ${{ env.VM_NAME }} \
            --name DockerExtension \
            --publisher Microsoft.Azure.Extensions \
            --version 1.1
        else
          echo "Development Virtual Machine already exists"
        fi

    - name: Get VM Public IP
      id: vm-ip
      run: |
        VM_IP=$(az vm show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --show-details --query publicIps --output tsv)
        echo "VM_IP=$VM_IP" >> $GITHUB_OUTPUT
        echo "Development VM Public IP: $VM_IP"

    - name: Deploy to Development VM
      run: |
        # Get ACR credentials
        ACR_PASSWORD=$(az acr credential show --name ${{ env.CONTAINER_REGISTRY }} --query "passwords[0].value" --output tsv)
        
        # Create deployment script
        cat > deploy-dev-script.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸš€ Starting development deployment on Azure VM..."
        
        # Install Docker Compose if not exists
        if ! command -v docker-compose &> /dev/null; then
          echo "Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
        fi
        
        # Login to ACR
        echo "Logging into Azure Container Registry..."
        echo "$ACR_PASSWORD" | docker login ${{ env.CONTAINER_REGISTRY }}.azurecr.io --username ${{ env.CONTAINER_REGISTRY }} --password-stdin
        
        # Create application directory
        mkdir -p /home/azureuser/smart-glasses-dev
        cd /home/azureuser/smart-glasses-dev
        
        # Create docker-compose.yml for development
        cat > docker-compose.yml << 'COMPOSE_EOF'
        services:
          postgres:
            image: postgres:15-alpine
            container_name: smart-glasses-dev-postgres
            environment:
              POSTGRES_USER: smartglasses
              POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-smartglasses123}
              POSTGRES_DB: smart_glasses_dev
            ports:
              - "5432:5432"
            volumes:
              - postgres_dev_data:/var/lib/postgresql/data
            restart: unless-stopped

          redis:
            image: redis:7-alpine
            container_name: smart-glasses-dev-redis
            ports:
              - "6379:6379"
            volumes:
              - redis_dev_data:/data
            command: redis-server --appendonly yes
            restart: unless-stopped

          app:
            image: ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-backend:${{ env.IMAGE_TAG }}
            container_name: smart-glasses-dev-app
            environment:
              SERVER_PORT: "8080"
              SERVER_ENV: "development"
              POSTGRES_DSN: "postgres://smartglasses:${POSTGRES_PASSWORD:-smartglasses123}@postgres:5432/smart_glasses_dev?sslmode=disable"
              REDIS_ADDR: "redis:6379"
              REDIS_PASSWORD: ""
              JWT_SECRET_KEY: "dev-secret-key"
              JWT_ACCESS_TOKEN_EXPIRY: "24h"
              JWT_REFRESH_TOKEN_EXPIRY: "168h"
              AZURE_OPENAI_ENDPOINT: "${AZURE_OPENAI_ENDPOINT}"
              AZURE_OPENAI_API_KEY: "${AZURE_OPENAI_API_KEY}"
              AZURE_OPENAI_DEPLOYMENT_NAME: "${AZURE_OPENAI_DEPLOYMENT_NAME:-gpt-4o}"
              AZURE_OPENAI_API_VERSION: "${AZURE_OPENAI_API_VERSION:-2024-08-01-preview}"
              AZURE_OPENAI_REALTIME_ENDPOINT: "${AZURE_OPENAI_REALTIME_ENDPOINT}"
              AZURE_OPENAI_REALTIME_API_KEY: "${AZURE_OPENAI_REALTIME_API_KEY}"
              AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME: "${AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME:-gpt-realtime}"
              AZURE_OPENAI_REALTIME_API_VERSION: "${AZURE_OPENAI_REALTIME_API_VERSION:-2024-10-01-preview}"
            ports:
              - "8080:8080"
            depends_on:
              - postgres
              - redis
            restart: unless-stopped

          frontend:
            image: ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-frontend:${{ env.IMAGE_TAG }}
            container_name: smart-glasses-dev-frontend
            ports:
              - "3000:80"
            depends_on:
              - app
            restart: unless-stopped

        volumes:
          postgres_dev_data:
          redis_dev_data:
        COMPOSE_EOF
        
        # Create .env file
        cat > .env << 'ENV_EOF'
        AZURE_OPENAI_ENDPOINT=$AZURE_OPENAI_ENDPOINT
        AZURE_OPENAI_API_KEY=$AZURE_OPENAI_API_KEY
        AZURE_OPENAI_DEPLOYMENT_NAME=$AZURE_OPENAI_DEPLOYMENT_NAME
        AZURE_OPENAI_API_VERSION=$AZURE_OPENAI_API_VERSION
        AZURE_OPENAI_REALTIME_ENDPOINT=$AZURE_OPENAI_REALTIME_ENDPOINT
        AZURE_OPENAI_REALTIME_API_KEY=$AZURE_OPENAI_REALTIME_API_KEY
        AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME=$AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME
        AZURE_OPENAI_REALTIME_API_VERSION=$AZURE_OPENAI_REALTIME_API_VERSION
        POSTGRES_PASSWORD=$POSTGRES_PASSWORD
        ENV_EOF
        
        # Stop existing services
        docker-compose down || true
        
        # Pull latest images
        docker-compose pull
        
        # Start services
        docker-compose up -d
        
        # Wait for services to start
        sleep 30
        
        # Check service status
        docker-compose ps
        
        # Clean up unused images
        docker image prune -f
        
        echo "âœ… Development deployment completed successfully!"
        EOF
        
        chmod +x deploy-dev-script.sh
        
        # Execute deployment script on VM
        az vm run-command invoke \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.VM_NAME }} \
          --command-id RunShellScript \
          --scripts @deploy-dev-script.sh \
          --parameters \
            ACR_PASSWORD="$ACR_PASSWORD" \
            AZURE_OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
            AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
            AZURE_OPENAI_DEPLOYMENT_NAME="${{ secrets.AZURE_OPENAI_DEPLOYMENT_NAME }}" \
            AZURE_OPENAI_API_VERSION="${{ secrets.AZURE_OPENAI_API_VERSION }}" \
            AZURE_OPENAI_REALTIME_ENDPOINT="${{ secrets.AZURE_OPENAI_REALTIME_ENDPOINT }}" \
            AZURE_OPENAI_REALTIME_API_KEY="${{ secrets.AZURE_OPENAI_REALTIME_API_KEY }}" \
            AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME="${{ secrets.AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME }}" \
            AZURE_OPENAI_REALTIME_API_VERSION="${{ secrets.AZURE_OPENAI_REALTIME_API_VERSION }}" \
            POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"

    - name: Development Health Check
      run: |
        VM_IP="${{ steps.vm-ip.outputs.VM_IP }}"
        
        echo "Waiting for development services to be ready..."
        sleep 60
        
        # Check backend health
        for i in {1..10}; do
          if curl -f "http://$VM_IP:8080/health"; then
            echo "âœ… Development backend service is healthy"
            break
          else
            echo "â³ Waiting for development backend service... (attempt $i/10)"
            sleep 10
          fi
        done
        
        # Check frontend
        if curl -f "http://$VM_IP:3000"; then
          echo "âœ… Development frontend service is accessible"
        else
          echo "âŒ Development frontend service check failed"
        fi
        
        echo ""
        echo "ðŸŽ‰ Development deployment completed successfully!"
        echo "ðŸŒ Development Frontend: http://$VM_IP:3000"
        echo "ðŸ”§ Development Backend API: http://$VM_IP:8080"
        echo "ðŸ’š Development Health Check: http://$VM_IP:8080/health"