name: Deploy to Azure VM

on:
  push:
    branches:
      - main
      - develop
      - staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
        - development
        - staging
        - production

env:
  AZURE_RESOURCE_GROUP: smart-glasses-rg
  VM_NAME: smart-glasses-vm
  LOCATION: eastus
  CONTAINER_REGISTRY: smartglassesacr
  IMAGE_NAME: smart-glasses-app
  IMAGE_TAG: ${{ github.sha }}

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login with OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Create or Update Resource Group
      run: |
        az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location ${{ env.LOCATION }}

    - name: Check and Configure Azure Container Registry
      run: |
        if az acr show --name ${{ env.CONTAINER_REGISTRY }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "âœ… Azure Container Registry '${{ env.CONTAINER_REGISTRY }}' already exists, using existing registry"
        else
          echo "Creating new Azure Container Registry '${{ env.CONTAINER_REGISTRY }}'..."
          az acr create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.CONTAINER_REGISTRY }} \
            --sku Basic \
            --admin-enabled true
          echo "âœ… New ACR created successfully"
        fi

    - name: Build and Push Docker Images to ACR
      run: |
        # Login to ACR
        az acr login --name ${{ env.CONTAINER_REGISTRY }}
        
        # Build and push backend image
        docker build -t ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-backend:${{ env.IMAGE_TAG }} .
        docker push ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-backend:${{ env.IMAGE_TAG }}
        
        # Build and push frontend image
        docker build -t ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-frontend:${{ env.IMAGE_TAG }} ./frontend
        docker push ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-frontend:${{ env.IMAGE_TAG }}

    - name: Check and Configure Virtual Machine
      run: |
        # Check if VM exists
        if az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "âœ… Virtual Machine '${{ env.VM_NAME }}' already exists, using existing VM"
          
          # Get VM status
          VM_STATUS=$(az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --show-details --query "powerState" --output tsv)
          echo "VM Status: $VM_STATUS"
          
          # Start VM if it's stopped
          if [[ "$VM_STATUS" == "VM stopped" ]] || [[ "$VM_STATUS" == "VM deallocated" ]]; then
            echo "Starting VM..."
            az vm start --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }}
            echo "Waiting for VM to start..."
            sleep 30
          fi
          
          # Ensure Docker is running on existing VM
          echo "Ensuring Docker is properly configured on existing VM..."
          az vm run-command invoke \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --command-id RunShellScript \
            --scripts "
              # Start Docker service if not running
              if ! systemctl is-active --quiet docker; then
                echo 'Starting Docker service...'
                sudo systemctl start docker
                sudo systemctl enable docker
              fi
              
              # Add user to docker group if not already
              sudo usermod -aG docker azureuser || true
              
              # Set Docker socket permissions
              sudo chmod 666 /var/run/docker.sock || true
              
              # Wait for Docker to be ready
              for i in {1..10}; do
                if docker info >/dev/null 2>&1; then
                  echo 'Docker is ready'
                  break
                else
                  echo 'Waiting for Docker...'
                  sleep 3
                fi
              done
              
              echo 'Docker status:'
              docker --version
              docker info
            " || echo "Warning: Docker configuration may need manual attention"
          
        else
          echo "Creating new Virtual Machine '${{ env.VM_NAME }}'..."
          
          # Create VM
          az vm create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --image Ubuntu2204 \
            --size Standard_B2s \
            --admin-username azureuser \
            --generate-ssh-keys \
            --public-ip-sku Standard \
            --nsg-rule SSH
          
          # Open required ports
          echo "Configuring network security group..."
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 80 --priority 1001
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 443 --priority 1002
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 3000 --priority 1003
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 8080 --priority 1004
          
          # Install Docker using custom script extension
          echo "Installing Docker on new VM..."
          az vm extension set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vm-name ${{ env.VM_NAME }} \
            --name CustomScript \
            --publisher Microsoft.Azure.Extensions \
            --settings '{
              "commandToExecute": "apt-get update && apt-get install -y apt-transport-https ca-certificates curl software-properties-common && curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - && add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" && apt-get update && apt-get install -y docker-ce docker-ce-cli containerd.io && systemctl start docker && systemctl enable docker && usermod -aG docker azureuser && chmod 666 /var/run/docker.sock"
            }'
          
          # Wait for Docker installation to complete
          echo "Waiting for Docker installation to complete..."
          sleep 60
          
          echo "âœ… New VM created and configured successfully"
        fi

    - name: Get VM Public IP
      id: vm-ip
      run: |
        VM_IP=$(az vm show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --show-details --query publicIps --output tsv)
        echo "VM_IP=$VM_IP" >> $GITHUB_OUTPUT
        echo "VM Public IP: $VM_IP"

    - name: Create deployment script
      run: |
        cat > deploy-script.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸš€ Starting deployment on Azure VM..."
        
        # Ensure we're running as root for system operations
        if [ "$EUID" -ne 0 ]; then
            echo "Switching to root for system operations..."
            exec sudo "$0" "$@"
        fi
        
        # Start Docker service
        echo "Ensuring Docker service is running..."
        systemctl start docker || true
        systemctl enable docker || true
        
        # Add azureuser to docker group
        echo "Adding azureuser to docker group..."
        usermod -aG docker azureuser || true
        
        # Set Docker socket permissions
        echo "Setting Docker socket permissions..."
        chmod 666 /var/run/docker.sock || true
        
        # Switch to azureuser for Docker operations
        echo "Switching to azureuser for application deployment..."
        su - azureuser << 'USEREOF'
        
        # Wait for Docker to be ready
        echo "Waiting for Docker to be ready..."
        for i in {1..30}; do
            if docker info >/dev/null 2>&1; then
                echo "Docker is ready"
                break
            else
                echo "Waiting for Docker... (attempt $i/30)"
                sleep 2
            fi
        done
        
        # Verify Docker is working
        if ! docker info >/dev/null 2>&1; then
            echo "âŒ Docker is not working properly"
            exit 1
        fi
        
        # Install Docker Compose if not exists
        if ! command -v docker-compose &> /dev/null; then
          echo "Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
        fi
        
        # Login to ACR
        echo "Logging into Azure Container Registry..."
        echo "$ACR_PASSWORD" | docker login ${{ env.CONTAINER_REGISTRY }}.azurecr.io --username ${{ env.CONTAINER_REGISTRY }} --password-stdin
        
        # Create application directory
        mkdir -p /home/azureuser/smart-glasses-app
        cd /home/azureuser/smart-glasses-app
        
        # Create docker-compose.yml for production
        cat > docker-compose.yml << 'COMPOSE_EOF'
        services:
          postgres:
            image: postgres:15-alpine
            container_name: smart-glasses-postgres
            environment:
              POSTGRES_USER: smartglasses
              POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-smartglasses123}
              POSTGRES_DB: smart_glasses
            ports:
              - "5432:5432"
            volumes:
              - postgres_data:/var/lib/postgresql/data
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U smartglasses"]
              interval: 10s
              timeout: 5s
              retries: 5
            restart: unless-stopped

          redis:
            image: redis:7-alpine
            container_name: smart-glasses-redis
            ports:
              - "6379:6379"
            volumes:
              - redis_data:/data
            command: redis-server --appendonly yes
            healthcheck:
              test: ["CMD", "redis-cli", "ping"]
              interval: 10s
              timeout: 5s
              retries: 5
            restart: unless-stopped

          app:
            image: ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-backend:${{ env.IMAGE_TAG }}
            container_name: smart-glasses-app
            environment:
              SERVER_PORT: "8080"
              SERVER_ENV: "production"
              POSTGRES_DSN: "postgres://smartglasses:${POSTGRES_PASSWORD:-smartglasses123}@postgres:5432/smart_glasses?sslmode=disable"
              REDIS_ADDR: "redis:6379"
              REDIS_PASSWORD: ""
              JWT_SECRET_KEY: "${JWT_SECRET_KEY:-change-this-in-production}"
              JWT_ACCESS_TOKEN_EXPIRY: "1h"
              JWT_REFRESH_TOKEN_EXPIRY: "168h"
              AZURE_OPENAI_ENDPOINT: "${AZURE_OPENAI_ENDPOINT}"
              AZURE_OPENAI_API_KEY: "${AZURE_OPENAI_API_KEY}"
              AZURE_OPENAI_DEPLOYMENT_NAME: "${AZURE_OPENAI_DEPLOYMENT_NAME:-gpt-4o}"
              AZURE_OPENAI_API_VERSION: "${AZURE_OPENAI_API_VERSION:-2024-08-01-preview}"
              AZURE_OPENAI_REALTIME_ENDPOINT: "${AZURE_OPENAI_REALTIME_ENDPOINT}"
              AZURE_OPENAI_REALTIME_API_KEY: "${AZURE_OPENAI_REALTIME_API_KEY}"
              AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME: "${AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME:-gpt-realtime}"
              AZURE_OPENAI_REALTIME_API_VERSION: "${AZURE_OPENAI_REALTIME_API_VERSION:-2024-10-01-preview}"
            ports:
              - "8080:8080"
            depends_on:
              postgres:
                condition: service_healthy
              redis:
                condition: service_healthy
            restart: unless-stopped

          frontend:
            image: ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-frontend:${{ env.IMAGE_TAG }}
            container_name: smart-glasses-frontend
            ports:
              - "3000:80"
            depends_on:
              - app
            restart: unless-stopped

        volumes:
          postgres_data:
          redis_data:
        COMPOSE_EOF
        
        # Create .env file
        cat > .env << 'ENV_EOF'
        AZURE_OPENAI_ENDPOINT=$AZURE_OPENAI_ENDPOINT
        AZURE_OPENAI_API_KEY=$AZURE_OPENAI_API_KEY
        AZURE_OPENAI_DEPLOYMENT_NAME=$AZURE_OPENAI_DEPLOYMENT_NAME
        AZURE_OPENAI_API_VERSION=$AZURE_OPENAI_API_VERSION
        AZURE_OPENAI_REALTIME_ENDPOINT=$AZURE_OPENAI_REALTIME_ENDPOINT
        AZURE_OPENAI_REALTIME_API_KEY=$AZURE_OPENAI_REALTIME_API_KEY
        AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME=$AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME
        AZURE_OPENAI_REALTIME_API_VERSION=$AZURE_OPENAI_REALTIME_API_VERSION
        POSTGRES_PASSWORD=$POSTGRES_PASSWORD
        JWT_SECRET_KEY=$JWT_SECRET_KEY
        ENV_EOF
        
        # Stop existing services gracefully
        echo "Stopping existing services..."
        docker-compose down --remove-orphans || true
        
        # Clean up old containers and images
        echo "Cleaning up old containers..."
        docker container prune -f || true
        docker image prune -f || true
        
        # Pull latest images
        echo "Pulling latest images..."
        docker-compose pull
        
        # Start services
        echo "Starting services..."
        docker-compose up -d
        
        # Wait for services to start
        echo "Waiting for services to start..."
        sleep 30
        
        # Check service status
        echo "Checking service status..."
        docker-compose ps
        
        # Verify services are healthy
        echo "Verifying service health..."
        for i in {1..10}; do
          if docker-compose ps | grep -q "Up"; then
            echo "Services are running"
            break
          else
            echo "Waiting for services to be ready... (attempt $i/10)"
            sleep 5
          fi
        done
        
        echo "âœ… Deployment completed successfully!"
        
        USEREOF
        
        echo "âœ… VM deployment script completed!"
        EOF
        
        chmod +x deploy-script.sh

    - name: Deploy to VM using Azure CLI
      run: |
        # Get ACR credentials
        ACR_PASSWORD=$(az acr credential show --name ${{ env.CONTAINER_REGISTRY }} --query "passwords[0].value" --output tsv)
        
        # Execute deployment script on VM
        az vm run-command invoke \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.VM_NAME }} \
          --command-id RunShellScript \
          --scripts @deploy-script.sh \
          --parameters \
            ACR_PASSWORD="$ACR_PASSWORD" \
            AZURE_OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
            AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
            AZURE_OPENAI_DEPLOYMENT_NAME="${{ secrets.AZURE_OPENAI_DEPLOYMENT_NAME }}" \
            AZURE_OPENAI_API_VERSION="${{ secrets.AZURE_OPENAI_API_VERSION }}" \
            AZURE_OPENAI_REALTIME_ENDPOINT="${{ secrets.AZURE_OPENAI_REALTIME_ENDPOINT }}" \
            AZURE_OPENAI_REALTIME_API_KEY="${{ secrets.AZURE_OPENAI_REALTIME_API_KEY }}" \
            AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME="${{ secrets.AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME }}" \
            AZURE_OPENAI_REALTIME_API_VERSION="${{ secrets.AZURE_OPENAI_REALTIME_API_VERSION }}" \
            POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
            JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}"

    - name: Health Check
      run: |
        VM_IP="${{ steps.vm-ip.outputs.VM_IP }}"
        
        echo "Waiting for services to be ready..."
        sleep 60
        
        # Check backend health
        for i in {1..10}; do
          if curl -f "http://$VM_IP:8080/health"; then
            echo "âœ… Backend service is healthy"
            break
          else
            echo "â³ Waiting for backend service... (attempt $i/10)"
            sleep 10
          fi
        done
        
        # Check frontend
        if curl -f "http://$VM_IP:3000"; then
          echo "âœ… Frontend service is accessible"
        else
          echo "âŒ Frontend service check failed"
          exit 1
        fi
        
        echo ""
        echo "ðŸŽ‰ Deployment completed successfully!"
        echo "ðŸŒ Frontend: http://$VM_IP:3000"
        echo "ðŸ”§ Backend API: http://$VM_IP:8080"
        echo "ðŸ’š Health Check: http://$VM_IP:8080/health"