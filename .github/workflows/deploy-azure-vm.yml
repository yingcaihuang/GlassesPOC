name: Deploy to Azure VM

on:
  push:
    branches:
      - main
      - develop
      - staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
        - development
        - staging
        - production

env:
  AZURE_RESOURCE_GROUP: smart-glasses-rg
  VM_NAME: smart-glasses-vm
  LOCATION: eastus
  CONTAINER_REGISTRY: smartglassesacr
  IMAGE_NAME: smart-glasses-app
  IMAGE_TAG: ${{ github.sha }}

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login with OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Create or Update Resource Group
      run: |
        az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location ${{ env.LOCATION }}

    - name: Check and Configure Azure Container Registry
      run: |
        if az acr show --name ${{ env.CONTAINER_REGISTRY }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "✅ Azure Container Registry '${{ env.CONTAINER_REGISTRY }}' already exists, using existing registry"
        else
          echo "Creating new Azure Container Registry '${{ env.CONTAINER_REGISTRY }}'..."
          az acr create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.CONTAINER_REGISTRY }} \
            --sku Basic \
            --admin-enabled true
          echo "✅ New ACR created successfully"
        fi

    - name: Build and Push Docker Images to ACR
      run: |
        # Login to ACR
        az acr login --name ${{ env.CONTAINER_REGISTRY }}
        
        # Build and push backend image
        docker build -t ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-backend:${{ env.IMAGE_TAG }} .
        docker push ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-backend:${{ env.IMAGE_TAG }}
        
        # Build and push frontend image
        docker build -t ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-frontend:${{ env.IMAGE_TAG }} ./frontend
        docker push ${{ env.CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}-frontend:${{ env.IMAGE_TAG }}

    - name: Check and Configure Virtual Machine
      run: |
        # Check if VM exists
        if az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "✅ Virtual Machine '${{ env.VM_NAME }}' already exists, using existing VM"
          
          # Get VM status
          VM_STATUS=$(az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --show-details --query "powerState" --output tsv)
          echo "VM Status: $VM_STATUS"
          
          # Start VM if it's stopped
          if [[ "$VM_STATUS" == "VM stopped" ]] || [[ "$VM_STATUS" == "VM deallocated" ]]; then
            echo "Starting VM..."
            az vm start --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }}
            echo "Waiting for VM to start..."
            sleep 30
          fi
          
          # Ensure VM has system-assigned managed identity
          echo "Checking if VM already has managed identity..."
          EXISTING_IDENTITY=$(az vm identity show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query systemAssignedIdentity --output tsv 2>/dev/null || echo "")
          
          if [ -z "$EXISTING_IDENTITY" ] || [ "$EXISTING_IDENTITY" = "None" ]; then
            echo "Assigning managed identity to VM..."
            az vm identity assign --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }}
          else
            echo "✅ VM already has managed identity: $EXISTING_IDENTITY"
          fi
          
        else
          echo "Creating new Virtual Machine '${{ env.VM_NAME }}'..."
          
          # Create VM with system-assigned managed identity
          az vm create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --image Ubuntu2204 \
            --size Standard_B2s \
            --admin-username azureuser \
            --generate-ssh-keys \
            --public-ip-sku Standard \
            --nsg-rule SSH \
            --assign-identity
          
          # Open required ports
          echo "Configuring network security group..."
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 80 --priority 1001
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 443 --priority 1002
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 3000 --priority 1003
          az vm open-port --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --port 8080 --priority 1004
          
          # Install Docker using custom script extension
          echo "Installing Docker on new VM..."
          az vm extension set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vm-name ${{ env.VM_NAME }} \
            --name CustomScript \
            --publisher Microsoft.Azure.Extensions \
            --settings '{
              "commandToExecute": "apt-get update && apt-get install -y apt-transport-https ca-certificates curl software-properties-common && curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - && add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" && apt-get update && apt-get install -y docker-ce docker-ce-cli containerd.io && systemctl start docker && systemctl enable docker && usermod -aG docker azureuser && chmod 666 /var/run/docker.sock"
            }'
          
          # Wait for Docker installation to complete
          echo "Waiting for Docker installation to complete..."
          sleep 60
          
          echo "✅ New VM created and configured successfully"
        fi
        
        # Get VM's managed identity principal ID
        VM_PRINCIPAL_ID=$(az vm identity show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query principalId --output tsv)
        echo "VM Principal ID: $VM_PRINCIPAL_ID"
        
        # Grant VM's managed identity access to ACR
        echo "Checking ACR access permissions..."
        ACR_ID=$(az acr show --name ${{ env.CONTAINER_REGISTRY }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query id --output tsv)
        
        # Check if role assignment already exists
        EXISTING_ASSIGNMENT=$(az role assignment list --assignee $VM_PRINCIPAL_ID --scope $ACR_ID --role AcrPull --query "[0].id" --output tsv 2>/dev/null || echo "")
        
        if [ -z "$EXISTING_ASSIGNMENT" ]; then
          echo "Assigning AcrPull role to VM's managed identity..."
          # Try to assign role, but continue if it fails (might be permission issue)
          az role assignment create \
            --assignee $VM_PRINCIPAL_ID \
            --role AcrPull \
            --scope $ACR_ID || {
            echo "⚠️  Role assignment failed - this might be due to insufficient permissions"
            echo "ℹ️  You may need to manually assign the AcrPull role to the VM's managed identity"
            echo "ℹ️  VM Principal ID: $VM_PRINCIPAL_ID"
            echo "ℹ️  ACR Resource ID: $ACR_ID"
            echo "ℹ️  Command: az role assignment create --assignee $VM_PRINCIPAL_ID --role AcrPull --scope $ACR_ID"
          }
        else
          echo "✅ AcrPull role already assigned to VM's managed identity"
        fi
        
        echo "✅ VM configured with managed identity"

    - name: Get VM Public IP
      id: vm-ip
      run: |
        VM_IP=$(az vm show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --show-details --query publicIps --output tsv)
        echo "VM_IP=$VM_IP" >> $GITHUB_OUTPUT
        echo "VM Public IP: $VM_IP"

    - name: Upload deployment files to VM
      run: |
        # Create glass directory and upload the deployment script and manager
        az vm run-command invoke \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.VM_NAME }} \
          --command-id RunShellScript \
          --scripts "
            mkdir -p /tmp/glass
            curl -s -o /tmp/glass/vm-deploy.sh https://raw.githubusercontent.com/${{ github.repository }}/main/scripts/vm-deploy.sh
            curl -s -o /tmp/glass/glass-manager.sh https://raw.githubusercontent.com/${{ github.repository }}/main/scripts/glass-manager.sh
            curl -s -o /tmp/glass/check-env-vars.sh https://raw.githubusercontent.com/${{ github.repository }}/main/scripts/check-env-vars.sh
            chmod +x /tmp/glass/vm-deploy.sh
            chmod +x /tmp/glass/glass-manager.sh
            chmod +x /tmp/glass/check-env-vars.sh
            
            # 创建便捷的符号链接
            ln -sf /tmp/glass/glass-manager.sh /usr/local/bin/glass 2>/dev/null || true
            
            echo '✅ 部署脚本和管理工具已上传到 /tmp/glass/'
            echo 'ℹ️  可以使用以下命令管理应用:'
            echo '   cd /tmp/glass && ./glass-manager.sh status'
            echo '   或直接使用: glass status'
            echo '   检查环境变量: ./check-env-vars.sh'
          "

    - name: Execute deployment on VM
      run: |
        # Execute deployment script on VM with environment variables
        az vm run-command invoke \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.VM_NAME }} \
          --command-id RunShellScript \
          --scripts "
            export CONTAINER_REGISTRY='${{ env.CONTAINER_REGISTRY }}'
            export IMAGE_NAME='${{ env.IMAGE_NAME }}'
            export IMAGE_TAG='${{ env.IMAGE_TAG }}'
            export AZURE_OPENAI_ENDPOINT='${{ secrets.AZURE_OPENAI_ENDPOINT }}'
            export AZURE_OPENAI_API_KEY='${{ secrets.AZURE_OPENAI_API_KEY }}'
            export AZURE_OPENAI_DEPLOYMENT_NAME='${{ secrets.AZURE_OPENAI_DEPLOYMENT_NAME }}'
            export AZURE_OPENAI_API_VERSION='${{ secrets.AZURE_OPENAI_API_VERSION }}'
            export AZURE_OPENAI_REALTIME_ENDPOINT='${{ secrets.AZURE_OPENAI_REALTIME_ENDPOINT }}'
            export AZURE_OPENAI_REALTIME_API_KEY='${{ secrets.AZURE_OPENAI_REALTIME_API_KEY }}'
            export AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME='${{ secrets.AZURE_OPENAI_REALTIME_DEPLOYMENT_NAME }}'
            export AZURE_OPENAI_REALTIME_API_VERSION='${{ secrets.AZURE_OPENAI_REALTIME_API_VERSION }}'
            export POSTGRES_PASSWORD='${{ secrets.POSTGRES_PASSWORD }}'
            export JWT_SECRET_KEY='${{ secrets.JWT_SECRET_KEY }}'
            
            # Run the deployment script
            /tmp/glass/vm-deploy.sh
          "

    - name: Health Check
      run: |
        VM_IP="${{ steps.vm-ip.outputs.VM_IP }}"
        
        echo "🏥 开始健康检查..."
        echo "🌐 VM IP: $VM_IP"
        
        # Wait for services to be ready
        echo "⏳ 等待服务准备就绪..."
        sleep 90
        
        # Check backend health with retries
        echo "🔍 检查后端服务健康状态..."
        BACKEND_HEALTHY=false
        for i in {1..15}; do
          echo "尝试 $i/15: 检查后端健康状态..."
          if curl -f -s --connect-timeout 10 --max-time 30 "http://$VM_IP:8080/health"; then
            echo "✅ 后端服务健康检查通过"
            BACKEND_HEALTHY=true
            break
          else
            echo "⏳ 等待后端服务... (尝试 $i/15)"
            sleep 15
          fi
        done
        
        if [ "$BACKEND_HEALTHY" = false ]; then
          echo "❌ 后端服务健康检查失败"
          echo "🔍 尝试获取服务状态..."
          
          # Try to get service status from VM
          az vm run-command invoke \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --command-id RunShellScript \
            --scripts "
              cd /tmp/glass
              echo '📊 服务状态:'
              sudo -u azureuser docker-compose ps
              echo '📜 服务日志:'
              sudo -u azureuser docker-compose logs --tail=30
            " || echo "无法获取服务状态"
          
          exit 1
        fi
        
        # Check frontend with retries
        echo "🔍 检查前端服务..."
        FRONTEND_HEALTHY=false
        for i in {1..10}; do
          echo "尝试 $i/10: 检查前端服务..."
          if curl -f -s --connect-timeout 10 --max-time 30 "http://$VM_IP:3000" >/dev/null; then
            echo "✅ 前端服务可访问"
            FRONTEND_HEALTHY=true
            break
          else
            echo "⏳ 等待前端服务... (尝试 $i/10)"
            sleep 10
          fi
        done
        
        if [ "$FRONTEND_HEALTHY" = false ]; then
          echo "❌ 前端服务检查失败"
          exit 1
        fi
        
        # Test API endpoints
        echo "🧪 测试 API 端点..."
        
        # Test health endpoint with detailed response
        echo "🔍 测试健康检查端点..."
        HEALTH_RESPONSE=$(curl -s "http://$VM_IP:8080/health" || echo "请求失败")
        echo "健康检查响应: $HEALTH_RESPONSE"
        
        # Test registration endpoint (should work if database is properly set up)
        echo "🔍 测试用户注册端点..."
        REGISTER_TEST=$(curl -s -w "%{http_code}" -X POST "http://$VM_IP:8080/api/auth/register" \
          -H "Content-Type: application/json" \
          -d '{
            "username": "testuser_'$(date +%s)'",
            "email": "test'$(date +%s)'@example.com",
            "password": "testpassword123"
          }' 2>/dev/null || echo "000")
        
        echo "注册端点测试响应: $REGISTER_TEST"
        
        if [[ "$REGISTER_TEST" == *"200"* ]] || [[ "$REGISTER_TEST" == *"201"* ]]; then
          echo "✅ 用户注册端点正常 - 数据库连接正常"
        elif [[ "$REGISTER_TEST" == *"400"* ]] || [[ "$REGISTER_TEST" == *"409"* ]]; then
          echo "✅ 用户注册端点响应正常 (可能是验证错误，但端点可访问)"
        else
          echo "⚠️  用户注册端点可能有问题，但继续部署"
        fi
        
        echo ""
        echo "🎉 健康检查完成！"
        echo "🌐 前端应用: http://$VM_IP:3000"
        echo "🔧 后端 API: http://$VM_IP:8080"
        echo "💚 健康检查: http://$VM_IP:8080/health"